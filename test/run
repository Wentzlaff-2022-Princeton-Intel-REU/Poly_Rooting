#!/usr/bin/env node

const path = require('node:path');
const stream = require('node:stream');
const fs = require('node:fs');
const readline = require('node:readline');
const child_process = require('node:child_process');

const timeout = Symbol('timeout');

process.on('uncaughtException', function (err) {
    if (err.code === 'EPIPE')
        return;
    console.error(err.stack);
    process.exit(4);
});

const prog = process.argv[2];
const suite = process.argv[3];
if (!prog || !suite) {
    console.error('Usage: ./test/run <path/to/executable> <suite>');
    process.exit(2);
}
fs.accessSync(prog, fs.constants.R_OK | fs.constants.X_OK);

function run(n, coeffs) {
    return new Promise((resolve, reject) => {
        const cp = child_process.execFile(prog, ['1e-14'], {
            timeout: 1000,
            killSignal: 'SIGABRT',
        }, (err, stdout, stderr) => {
            if (cp.signalCode === 'SIGABRT') {
                resolve(timeout);
            } else if (err) {
                resolve(cp.signalCode);
            } else {
                if (process.env.VERBOSE)
                    console.error(stdout, stderr);
                const rst = stdout.split(/\s+/).filter((s) => s).map((s) => +s).filter((v) => !isNaN(v));
                resolve(rst);
            }
        });
        try {
            const stdinStream = new stream.Readable();
            stdinStream.push(`${n}\n`);
            for (const c of coeffs)
                stdinStream.push(`${c}\n`);
            stdinStream.push(null);
            stdinStream.pipe(cp.stdin);
        } catch (e) {
            // ignore
        }
    });
}

function check(rst, roots) {
    if (rst === timeout) {
        console.log('Timeout');
        return false;
    }
    if (!Array.isArray(rst)) {
        console.log(rst);
        return false;
    }
    if (!rst.length) {
        console.log('No root reported');
        return false;
    }
    if (process.env.VERBOSE)
        console.log('Desired:', roots, 'Actual:', rst);
    let goodRoots = 0, badRoots = 0;
    const numErrors = [];
    for (const e of rst) {
        const r = roots.find((r) => Math.abs(e - r) < 1e-10);
        if (r === undefined)
            badRoots++;
        else
            goodRoots++, numErrors.push(Math.abs(e - r));
    }
    if (!goodRoots) {
        console.log(`${rst.length}/${roots.length} roots reported but all bad`);
        return false;
    }
    const maxErr = numErrors.reduce((a, b) => Math.max(a, b));
    const avgErr = numErrors.reduce((a, b) => a + b) / goodRoots;
    if (goodRoots < roots.length) {
        console.log(`${rst.length} reported, ${goodRoots} valid, err:  ${avgErr} avg.  ${maxErr} max.`);
        return false;
    }
    if (badRoots) {
        console.log(`all ${roots.length} found but ${badRoots} fake reported, err:  ${avgErr} avg.  ${maxErr} max.`);
        return false;
    }
    console.log(`all ${roots.length} found, err:  ${avgErr} avg.  ${maxErr} max.`);
    return true;
}

async function processLineByLine(fn) {
    const fileStream = fs.createReadStream(fn);
    const rl = readline.createInterface({
        input: fileStream,
        crlfDelay: Infinity,
    });
    let testId = 1;
    let pass = 0, fail = 0;
    for await (const line of rl) {
        const sp = line.split(' ').filter((s) => s).map((s) => +s);
        const [n] = sp.splice(0, 1);
        const coeffs = sp.splice(0, n + 1);
        const roots = sp;
        process.stdout.write(`Test #${testId} (n=${n}): `);
        if (roots.length !== n)
            throw new Error(`Wrong test case ${line}`);

        const rst = await run(n, coeffs);
        if (check(rst, roots))
            pass++;
        else
            fail++;
        testId++;
    }
    console.error(`Total Pass: ${pass} Total Fail: ${fail}`);
}

processLineByLine(path.join(__dirname, 'data', `${suite}.txt`));
